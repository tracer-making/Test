# 开发规范

本指南定义了"溯洄遗梦"项目的开发规范和最佳实践，以确保代码质量和团队协作的一致性。

## 编码规范

### 命名约定

1. **类名**：使用PascalCase（首字母大写）
   ```cpp
   class BattleState;
   class CardRenderer;
   ```

2. **函数名**：使用camelCase（驼峰命名法）
   ```cpp
   void initializeBattle();
   void renderUI(App& app);
   ```

3. **变量名**：使用camelCase
   ```cpp
   int playerHealth_;
   bool isAnimating_;
   ```

4. **常量名**：使用SCREAMING_SNAKE_CASE（全大写加下划线）
   ```cpp
   const int MAX_ITEMS = 3;
   const float ANIMATION_DURATION = 0.5f;
   ```

5. **私有成员变量**：以下划线结尾
   ```cpp
   int playerHealth_;
   bool isAnimating_;
   ```

### 文件组织

1. **头文件保护**：使用`#pragma once`
   ```cpp
   #pragma once
   ```

2. **包含顺序**：
   - 对应的头文件（如果是实现文件）
   - C/C++标准库
   - 第三方库
   - 项目内其他头文件

3. **文件命名**：与类名保持一致
   ```
   BattleState.h/.cpp
   CardRenderer.h/.cpp
   ```

### 代码格式

1. **缩进**：使用4个空格，不使用Tab
2. **大括号**：使用Allman风格
   ```cpp
   void function()
   {
       if (condition)
       {
           // code
       }
   }
   ```
3. **行长度**：尽量保持在100字符以内
4. **空行**：在逻辑块之间使用空行分隔

### 注释规范

1. **类注释**：在类定义前添加注释，说明类的用途
   ```cpp
   // 战斗状态：管理战斗界面和逻辑
   class BattleState : public State
   {
       // ...
   };
   ```

2. **函数注释**：在函数声明前添加注释，说明功能、参数和返回值
   ```cpp
   /**
    * 初始化战斗
    * @param app 应用程序引用
    */
   void initializeBattle();
   ```

3. **复杂逻辑注释**：在复杂代码段前添加注释说明
   ```cpp
   // 计算墨尺平衡：玩家伤害累加，敌人伤害扣减
   meterNet_ = playerDamageThisCycle_ - enemyDamageThisCycle_;
   ```

## 架构设计原则

### 状态机架构

游戏采用状态机架构，每个游戏界面或模式对应一个状态类：

1. **状态继承**：所有状态类继承自`State`基类
2. **状态切换**：通过设置标志位在主循环中进行状态切换
3. **资源管理**：在`onEnter`和`onExit`中管理资源的加载和释放

### 单一职责原则

每个类应该只有一个改变的理由：

1. **State类**：只负责管理特定状态的逻辑和渲染
2. **Store类**：只负责数据存储和访问
3. **Renderer类**：只负责渲染逻辑

### 依赖管理

1. **前向声明**：尽可能使用前向声明减少包含依赖
   ```cpp
   class App;
   class State;
   ```

2. **接口隔离**：通过接口减少类之间的耦合

## 内存管理

### 智能指针使用

1. **unique_ptr**：用于独占所有权的资源管理
   ```cpp
   std::unique_ptr<State> state_;
   ```

2. **避免原始指针**：尽量避免使用原始指针进行内存管理

### 资源生命周期

1. **RAII原则**：资源获取即初始化
2. **及时释放**：在不需要时及时释放资源
3. **避免内存泄漏**：确保每个分配的资源都有对应的释放

## SDL2使用规范

### 渲染器管理

1. **单一渲染器**：整个应用使用单一SDL_Renderer实例
2. **纹理管理**：及时创建和销毁纹理资源
3. **渲染顺序**：按照背景→元素→UI的顺序进行渲染

### 事件处理

1. **事件分发**：在handleEvent中处理所有SDL事件
2. **输入处理**：合理处理鼠标和键盘输入
3. **事件类型**：只处理需要的事件类型，忽略无关事件

## 错误处理

### 异常安全

1. **避免异常**：项目中不使用C++异常机制
2. **错误码**：使用返回值或状态变量表示错误
3. **资源清理**：确保在错误情况下也能正确清理资源

### 日志记录

1. **关键路径**：在关键逻辑路径上添加日志输出
2. **错误信息**：提供清晰的错误信息
3. **调试信息**：在调试版本中输出详细的调试信息

## 性能优化

### 渲染优化

1. **避免重复渲染**：只在需要时重新渲染
2. **纹理复用**：复用相同的纹理资源
3. **批处理**：尽可能批量处理渲染操作

### 内存优化

1. **对象池**：对于频繁创建和销毁的对象使用对象池
2. **预分配**：预先分配可能需要的内存空间
3. **避免频繁分配**：减少运行时的内存分配操作

### 算法优化

1. **时间复杂度**：选择合适的时间复杂度算法
2. **空间复杂度**：在时间和空间之间做出合理权衡
3. **缓存友好**：尽量使用缓存友好的数据结构和算法

## 测试规范

### 单元测试

1. **测试覆盖**：核心逻辑应有相应的单元测试
2. **测试独立**：每个测试应独立运行，不依赖其他测试
3. **边界条件**：测试应覆盖边界条件和异常情况

### 集成测试

1. **状态切换**：测试不同状态之间的切换
2. **系统集成**：测试各子系统之间的集成
3. **用户流程**：测试完整的用户操作流程

## 版本控制

### 提交信息

1. **格式规范**：使用清晰的提交信息格式
2. **内容描述**：准确描述修改的内容和原因
3. **关联任务**：关联相关的任务或问题编号

### 分支管理

1. **功能分支**：为每个新功能创建独立的分支
2. **主分支保护**：保护主分支，只允许通过Pull Request合并
3. **定期同步**：定期与主分支同步，避免大的合并冲突

遵循这些开发规范将有助于维护代码质量，提高团队协作效率，并确保项目的长期可维护性。