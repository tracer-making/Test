# 核心模块详解

<cite>
**Referenced Files in This Document**   
- [App.h](file://Tracer/src/core/App.h)
- [App.cpp](file://Tracer/src/core/App.cpp)
- [State.h](file://Tracer/src/core/State.h)
- [MainMenuState.cpp](file://Tracer/src/states/MainMenuState.cpp)
- [BattleState.cpp](file://Tracer/src/states/BattleState.cpp)
- [TestState.cpp](file://Tracer/src/states/TestState.cpp)
</cite>

## 目录
1. [App类与State基类概述](#app类与state基类概述)
2. [App类的构造与初始化](#app类的构造与初始化)
3. [状态管理与setState方法](#状态管理与setstate方法)
4. [主循环run方法解析](#主循环run方法解析)
5. [State基类设计与虚函数](#state基类设计与虚函数)
6. [状态派生类实现模板](#状态派生类实现模板)
7. [内存管理与智能指针](#内存管理与智能指针)

## App类与State基类概述

本系统采用状态机（State Machine）模式进行核心流程控制，由`App`类作为全局上下文容器，管理SDL子系统、窗口、渲染器等核心资源，并通过`State`基类定义状态接口。`App`类负责初始化、主循环执行和状态切换，而所有具体的游戏状态（如主菜单、战斗、地图探索等）均通过继承`State`基类来实现。这种设计实现了逻辑与资源的分离，确保了状态间的平滑过渡和资源的统一管理。

**Section sources**
- [App.h](file://Tracer/src/core/App.h#L1-L31)
- [State.h](file://Tracer/src/core/State.h#L1-L18)

## App类的构造与初始化

`App`类的构造函数`App()`是一个空实现，其真正的初始化工作由`init`方法完成。`init`方法接收窗口标题、宽度和高度作为参数，依次执行以下关键步骤：

1.  **SDL子系统初始化**：调用`SDL_Init`初始化视频、定时器和事件子系统。若失败，通过`SDL_Log`记录错误并返回`false`。
2.  **字体库初始化**：调用`TTF_Init`初始化SDL_ttf字体库，为后续的文本渲染做准备。
3.  **窗口创建**：使用`SDL_CreateWindow`创建一个居中显示的窗口。其标志位`SDL_WINDOW_SHOWN`确保窗口创建后立即显示。
4.  **渲染器配置**：通过`SDL_CreateRenderer`为窗口创建一个硬件加速且与垂直同步（VSync）同步的渲染器，这能有效防止画面撕裂。
5.  **内部状态设置**：成功初始化后，将`running_`标志位设为`true`，表示应用已进入运行状态。

该过程将所有底层资源的初始化封装在`App`类中，为上层状态提供了统一的访问接口。

**Section sources**
- [App.h](file://Tracer/src/core/App.h#L10-L11)
- [App.cpp](file://Tracer/src/core/App.cpp#L12-L38)

## 状态管理与setState方法

`App`类通过`std::unique_ptr<State>`智能指针来管理当前状态，`setState`方法是实现状态安全过渡的核心。

当调用`setState`并传入一个新的`State`对象时，该方法会执行一个原子性的三步操作：
1.  **旧状态退出**：如果当前存在一个活动状态（`state_`不为空），则调用其`onExit`方法。此方法用于执行资源清理、数据保存等收尾工作。
2.  **所有权转移**：使用`std::move`将新状态的所有权安全地转移给`state_`成员变量。`std::move`确保了资源的唯一所有权，避免了深拷贝的开销和潜在的内存泄漏。
3.  **新状态进入**：如果新状态成功接管，立即调用其`onEnter`方法。此方法用于预加载资源、初始化数据、设置UI等准备工作。

这种“先退出旧状态，再进入新状态”的模式，保证了状态切换过程中的数据一致性和资源完整性，是实现流畅游戏体验的关键。

**Section sources**
- [App.h](file://Tracer/src/core/App.h#L16-L17)
- [App.cpp](file://Tracer/src/core/App.cpp#L70-L77)

## 主循环run方法解析

`App`类的`run`方法实现了游戏的主循环（Game Loop），其逻辑严谨，协调了事件处理、逻辑更新和画面渲染三大任务。

1.  **事件轮询**：使用`SDL_PollEvent`在一个嵌套循环中处理所有待处理的事件。当收到`SDL_QUIT`事件时，将`running_`标志位设为`false`，从而退出主循环。所有事件也会被传递给当前状态的`handleEvent`方法进行处理。
2.  **时间步进计算**：利用`SDL_GetPerformanceCounter`和`SDL_GetPerformanceFrequency`精确计算出两次循环之间的时间差（`deltaSeconds`）。这个时间步长对于实现与帧率无关的平滑动画至关重要。
3.  **状态更新**：将计算出的时间步长传递给当前状态的`update`方法，驱动游戏逻辑的演进，如角色移动、AI决策等。
4.  **渲染协调**：首先设置背景色并清除渲染器，然后调用当前状态的`render`方法进行画面绘制，最后调用`SDL_RenderPresent`将渲染结果提交到屏幕。

整个循环以“处理输入 -> 更新逻辑 -> 渲染画面”的标准模式运行，确保了游戏的实时性和响应性。

**Section sources**
- [App.h](file://Tracer/src/core/App.h#L15-L15)
- [App.cpp](file://Tracer/src/core/App.cpp#L40-L68)

## State基类设计与虚函数

`State`基类是一个抽象接口，定义了所有游戏状态必须实现的五个纯虚函数，明确了状态的生命周期和行为规范。

- **`onEnter(App& app)`**：在状态被激活时调用。设计意图是进行资源预加载和初始化。例如，在`MainMenuState`中，此方法加载了中文字体、创建了标题纹理并初始化了所有按钮。**调用时机**：在`App::setState`方法中，新状态被接管后立即调用。
- **`onExit(App& app)`**：在状态被销毁前调用。设计意图是进行资源清理和数据持久化。例如，在`TestState`的析构函数中，显式关闭了字体和销毁了纹理。**调用时机**：在`App::setState`方法中，旧状态被替换前调用。
- **`handleEvent(App& app, const SDL_Event& e)`**：处理所有输入事件。设计意图是将事件分发给状态内部的UI组件或游戏逻辑。例如，`MainMenuState`在此方法中处理了按钮的点击事件。**调用时机**：在`App::run`的事件轮询阶段被调用。
- **`update(App& app, float deltaSeconds)`**：驱动游戏逻辑更新。设计意图是根据时间步长更新游戏世界的状态。例如，`BattleState`在此方法中模拟了阴阳平衡的缓慢变化。**调用时机**：在`App::run`的更新阶段被调用。
- **`render(App& app)`**：负责画面渲染。设计意图是将当前状态的视觉内容绘制到屏幕上。**调用时机**：在`App::run`的渲染阶段被调用。

**Section sources**
- [State.h](file://Tracer/src/core/State.h#L10-L17)
- [MainMenuState.cpp](file://Tracer/src/states/MainMenuState.cpp#L20-L110)
- [TestState.cpp](file://Tracer/src/states/TestState.cpp#L20-L25)

## 状态派生类实现模板

从`State`基类派生新状态类的标准模板如下：

```cpp
class MyNewState : public State {
public:
    MyNewState() = default;
    ~MyNewState() override; // 建议显式声明析构函数

    void onEnter(App& app) override;
    void onExit(App& app) override;
    void handleEvent(App& app, const SDL_Event& e) override;
    void update(App& app, float deltaSeconds) override;
    void render(App& app) override;

private:
    // 状态私有成员变量
};

// 实现文件
MyNewState::~MyNewState() {
    // 在此处清理所有动态分配的资源
    // 例如：delete myPointer; TTF_CloseFont(myFont);
}

void MyNewState::onEnter(App& app) {
    // 初始化逻辑：加载资源、创建UI等
}

void MyNewState::onExit(App& app) {
    // 清理逻辑：释放资源、保存数据等
}

void MyNewState::handleEvent(App& app, const SDL_Event& e) {
    // 事件处理逻辑
}

void MyNewState::update(App& app, float deltaSeconds) {
    // 游戏逻辑更新
}

void MyNewState::render(App& app) {
    // 画面渲染逻辑
}
```

**常见实现错误**：
1.  **忘记清理资源**：在`onExit`或析构函数中未释放动态分配的内存（如`new`出的对象、`TTF_OpenFont`打开的字体），导致内存泄漏。
2.  **忽略基类析构函数**：虽然`State`的析构函数是`virtual`的，但派生类应显式声明自己的析构函数并确保其为`virtual`，以保证多态删除时能正确调用。
3.  **在`handleEvent`中直接修改状态**：直接在事件处理中调用`app.setState(...)`可能导致当前对象在事件处理完成前被销毁，引发未定义行为。应采用延迟切换策略，如`TestState`中使用`pendingTarget_`标志位，在`update`方法中再执行状态切换。

**Section sources**
- [State.h](file://Tracer/src/core/State.h#L10-L17)
- [TestState.cpp](file://Tracer/src/states/TestState.cpp#L18-L25)

## 内存管理与智能指针

本系统通过`std::unique_ptr<State>`智能指针来管理状态对象的生命周期，这是避免资源泄漏的核心策略。

`std::unique_ptr`是一种独占式智能指针，它保证了对所管理对象的唯一所有权。当`unique_ptr`被销毁（例如，`App`类的`state_`成员变量被新的`unique_ptr`赋值时），它会自动调用所管理对象的析构函数，并释放其占用的内存。

在`App::setState`方法中，`std::move(nextState)`将新状态的所有权从参数`nextState`转移给`state_`。当`state_`接管新对象时，它会自动销毁之前管理的旧状态对象。这种自动化的资源管理机制极大地降低了手动管理内存的复杂性，有效防止了因忘记`delete`而导致的内存泄漏，是现代C++程序安全性的基石。

**Section sources**
- [App.h](file://Tracer/src/core/App.h#L23-L23)
- [App.cpp](file://Tracer/src/core/App.cpp#L70-L77)