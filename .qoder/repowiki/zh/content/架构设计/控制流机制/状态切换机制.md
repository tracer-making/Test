# 状态切换机制

<cite>
**本文档中引用的文件**  
- [App.cpp](file://Tracer/src/core/App.cpp)
- [App.h](file://Tracer/src/core/App.h)
- [State.h](file://Tracer/src/core/State.h)
- [TestState.cpp](file://Tracer/src/states/TestState.cpp)
- [TestState.h](file://Tracer/src/states/TestState.h)
- [MapExploreState.cpp](file://Tracer/src/states/MapExploreState.cpp)
- [MapExploreState.h](file://Tracer/src/states/MapExploreState.h)
- [Button.h](file://Tracer/src/ui/Button.h)
</cite>

## 目录
1. [简介](#简介)
2. [状态切换核心机制](#状态切换核心机制)
3. [生命周期管理](#生命周期管理)
4. [跨状态跳转实现](#跨状态跳转实现)
5. [状态所有权与内存安全](#状态所有权与内存安全)
6. [调试与日志建议](#调试与日志建议)
7. [状态切换流程图](#状态切换流程图)
8. [结论](#结论)

## 简介
本项目采用基于 `std::unique_ptr` 的状态机设计模式，通过 `App` 类统一管理所有游戏状态对象的生命周期。状态切换过程安全、高效，利用智能指针的 RAII 特性自动管理资源，避免内存泄漏。每个状态继承自抽象基类 `State`，并实现 `onEnter` 和 `onExit` 方法以执行初始化与清理逻辑。`TestState` 作为功能测试入口，展示了如何通过按钮回调实现向其他状态（如 `MapExploreState`）的安全跳转。

## 状态切换核心机制
状态切换由 `App::setState(std::unique_ptr<State> nextState)` 方法驱动。该方法接收一个 `std::unique_ptr<State>` 类型的新状态对象，通过移动语义安全接管其所有权。

在切换过程中：
1. 若当前存在旧状态，先调用其 `onExit()` 方法进行清理。
2. 使用 `std::move` 将新状态指针赋值给内部成员 `state_`，自动释放旧状态内存。
3. 若新状态有效，调用其 `onEnter()` 方法完成初始化。

此设计确保了状态对象的唯一所有权归属 `App`，杜绝裸指针管理风险。

**状态切换核心方法**
[SPEC SYMBOL](file://Tracer/src/core/App.cpp#L70-L74)

**App 类声明**
[SPEC SYMBOL](file://Tracer/src/core/App.h#L7-L27)

**Section sources**
- [App.cpp](file://Tracer/src/core/App.cpp#L70-L74)
- [App.h](file://Tracer/src/core/App.h#L7-L27)

## 生命周期管理
状态对象的完整生命周期由 `App` 托管，关键阶段通过 `onEnter` 和 `onExit` 回调进行管理。

### onEnter() 初始化
当状态被激活时，`onEnter(App& app)` 被调用，用于：
- 加载字体、纹理等资源
- 创建 UI 组件（如按钮）
- 初始化内部数据结构
- 设置事件回调

例如，`TestState::onEnter()` 中加载了标题字体并创建了返回主菜单按钮。

### onExit() 清理
当状态即将被替换时，`onExit(App& app)` 被调用，用于：
- 释放动态分配的资源（如字体、纹理）
- 删除堆上创建的 UI 对象
- 保存临时数据

例如，`MapExploreState::onExit()` 显式销毁了标题纹理和字体资源。

**State 基类定义**
[SPEC SYMBOL](file://Tracer/src/core/State.h#L6-L14)

**MapExploreState 清理实现**
[SPEC SYMBOL](file://Tracer/src/states/MapExploreState.cpp#L80-L105)

**Section sources**
- [State.h](file://Tracer/src/core/State.h#L6-L14)
- [MapExploreState.cpp](file://Tracer/src/states/MapExploreState.cpp#L80-L105)

## 跨状态跳转实现
通过 `TestState` 中的按钮回调，展示了如何实现跨状态跳转。

### 按钮回调绑定
`Button` 类使用 `std::function<void()>` 作为回调类型。在 `TestState::onEnter()` 中，为返回按钮设置了一个 lambda 表达式回调：

```cpp
backButton_->setOnClick([&app]() {
    app.setState(std::unique_ptr<State>(new MainMenuState()));
});
```

该 lambda 捕获 `App` 实例引用，从而能够在点击时安全地发起状态切换。

### 延迟切换机制
为避免在事件处理过程中直接销毁当前状态对象，`TestState` 采用延迟切换策略：

- 在 `handleEvent` 中仅记录目标状态索引（`pendingTarget_`）
- 在 `update` 方法中执行实际的 `setState` 调用

此机制确保事件处理流程完整结束后再进行状态切换，防止未定义行为。

**TestState 按钮回调实现**
[SPEC SYMBOL](file://Tracer/src/states/TestState.cpp#L69-L75)

**延迟切换逻辑**
[SPEC SYMBOL](file://Tracer/src/states/TestState.cpp#L157-L197)

**Section sources**
- [TestState.cpp](file://Tracer/src/states/TestState.cpp#L69-L75)
- [TestState.cpp](file://Tracer/src/states/TestState.cpp#L157-L197)

## 状态所有权与内存安全
整个状态系统遵循“单一所有权”原则，所有状态对象均由 `App` 类内的 `std::unique_ptr<State> state_` 成员独占管理。

### 智能指针优势
- **自动释放**：当 `state_` 被新指针覆盖时，旧对象自动析构
- **防泄漏**：RAII 机制确保异常安全下的资源释放
- **无裸指针**：避免手动 `delete` 导致的双重释放或遗漏

### 状态创建方式
新状态通过 `new` 创建后立即封装为 `std::unique_ptr`，并通过 `setState` 传递给 `App`：

```cpp
app.setState(std::unique_ptr<State>(new MapExploreState()));
```

此后，`App` 完全掌控该对象的生命周期，客户端无需关心释放问题。

**App 状态成员声明**
[SPEC SYMBOL](file://Tracer/src/core/App.h#L27)

**Section sources**
- [App.h](file://Tracer/src/core/App.h#L27)

## 调试与日志建议
为便于追踪状态流转路径，建议在关键生命周期方法中添加日志输出。

### 推荐日志点
- `onEnter` 开始与结束
- `onExit` 开始与结束
- 状态切换触发点（如按钮点击）
- 资源加载/释放结果

例如，`TestState::onEnter()` 中使用 `SDL_Log` 输出屏幕尺寸、字体加载状态等信息，有助于快速定位初始化失败原因。

### 日志用途
- **追踪跳转路径**：确认状态流转是否符合预期
- **排查异常退出**：检查 `onExit` 是否被正确调用
- **性能分析**：评估状态加载耗时

**TestState 日志输出示例**
[SPEC SYMBOL](file://Tracer/src/states/TestState.cpp#L35-L37)

**Section sources**
- [TestState.cpp](file://Tracer/src/states/TestState.cpp#L35-L37)

## 状态切换流程图
```mermaid
flowchart TD
A[开始状态切换] --> B{是否存在旧状态?}
B --> |是| C[调用旧状态 onExit()]
B --> |否| D[直接接管新状态]
C --> D
D --> E[调用 std::move 赋值]
E --> F{新状态是否有效?}
F --> |是| G[调用新状态 onEnter()]
F --> |否| H[进入空状态]
G --> I[切换完成]
H --> I
```

**Diagram sources**
- [App.cpp](file://Tracer/src/core/App.cpp#L70-L74)

## 结论
本系统通过 `std::unique_ptr` 实现了安全、高效的状态管理机制。`App::setState` 方法利用智能指针特性自动完成旧状态资源释放与新状态接管，结合 `onEnter/onExit` 生命周期回调，确保了资源的正确初始化与清理。`TestState` 中的按钮回调展示了如何通过 lambda 表达式实现跨状态跳转，而延迟切换机制则保障了事件处理的安全性。整体设计遵循单一所有权原则，彻底规避了裸指针带来的内存管理风险，为游戏状态流转提供了稳定可靠的基础架构。