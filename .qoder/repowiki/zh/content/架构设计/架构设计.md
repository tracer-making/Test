# 架构设计

<cite>
**本文档中引用的文件**  
- [App.h](file://Tracer/src/core/App.h)
- [App.cpp](file://Tracer/src/core/App.cpp)
- [State.h](file://Tracer/src/core/State.h)
- [main.cpp](file://Tracer/src/main.cpp)
- [MainMenuState.h](file://Tracer/src/states/MainMenuState.h)
- [MainMenuState.cpp](file://Tracer/src/states/MainMenuState.cpp)
- [BattleState.h](file://Tracer/src/states/BattleState.h)
- [BattleState.cpp](file://Tracer/src/states/BattleState.cpp)
</cite>

## 目录
1. [引言](#引言)
2. [核心架构概览](#核心架构概览)
3. [状态模式实现分析](#状态模式实现分析)
4. [App类与状态机控制](#app类与状态机控制)
5. [主循环与时间步进机制](#主循环与时间步进机制)
6. [数据流与事件传递](#数据流与事件传递)
7. [渲染流程与UI结构](#渲染流程与ui结构)
8. [单例模式的应用与评估](#单例模式的应用与评估)
9. [架构权衡与改进空间](#架构权衡与改进空间)
10. [结论](#结论)

## 引言

《溯洄遗梦》是一款基于SDL2框架开发的C++游戏，其整体架构采用状态机驱动的设计模式。本设计文档旨在深入解析其核心架构，重点阐述以`App`类为中心的状态管理模式、状态切换机制、事件与渲染流程，以及整体架构的权衡与优化空间。通过UML类图与代码逻辑分析，揭示其如何通过`std::unique_ptr`安全管理状态对象，实现内存自动释放与平滑的状态过渡。

## 核心架构概览

游戏的核心架构围绕一个中心控制类`App`和一个抽象状态基类`State`构建。`App`作为整个游戏的运行容器，负责初始化SDL环境、管理主循环、处理事件分发，并通过`std::unique_ptr<State>`持有当前活动的状态对象。所有具体的游戏状态（如主菜单、战斗、卡牌管理等）都继承自`State`基类，并重写其定义的五大人机交互接口。

这种设计将游戏的不同阶段（如菜单、战斗、探索）解耦为独立的状态类，每个状态类封装了其特有的逻辑、事件处理和渲染行为。状态之间的切换由`App`统一管理，确保了控制流的清晰与安全。

```mermaid
classDiagram
class App {
-SDL_Window* window_
-SDL_Renderer* renderer_
-bool running_
-std : : unique_ptr<State> state_
+App()
+~App()
+init(title, width, height) bool
+shutdown() void
+run() void
+setState(nextState) void
+getWindow() SDL_Window*
+getRenderer() SDL_Renderer*
}
class State {
<<abstract>>
+~State() virtual
+onEnter(app) void
+onExit(app) void
+handleEvent(app, e) void
+update(app, deltaSeconds) void
+render(app) void
}
App o-- "1" "1" State : 聚合
State <|-- MainMenuState
State <|-- BattleState
State <|-- TestState
State <|-- DeckState
State <|-- MapExploreState
State <|-- EngraveState
State <|-- InkShopState
State <|-- BarterState
State <|-- BurnState
State <|-- HeritageState
State <|-- MemoryRepairState
State <|-- RelicPickupState
State <|-- SeekerState
State <|-- TemperState
class Button {
-SDL_Rect rect_
-std : : string text_
-_TTF_Font* font_
-SDL_Texture* textTex_
-std : : function<void()> onClick_
+setRect(rect) void
+setText(text) void
+setFont(font, renderer) void
+setOnClick(callback) void
+handleEvent(e) void
+render(renderer) void
}
MainMenuState --> Button : 使用
BattleState --> Button : 使用
```

**图示来源**
- [App.h](file://Tracer/src/core/App.h#L1-L30)
- [State.h](file://Tracer/src/core/State.h#L1-L17)
- [MainMenuState.h](file://Tracer/src/states/MainMenuState.h#L1-L69)
- [BattleState.h](file://Tracer/src/states/BattleState.h#L1-L81)

## 状态模式实现分析

本项目是状态设计模式（State Pattern）的经典实现。该模式允许一个对象在其内部状态改变时改变其行为，对象看起来似乎修改了它的类。

### State基类接口

`State`基类定义了五个核心的虚函数接口，构成了状态机的生命周期和交互契约：

1.  **`onEnter(App& app)`**: 当状态被激活并成为当前状态时调用。用于初始化该状态所需的资源，如加载字体、创建UI元素、重置游戏数据等。例如，`MainMenuState`在此函数中初始化了按钮、标题纹理和动态的数据流效果。
2.  **`onExit(App& app)`**: 当状态即将被切换走时调用。用于清理该状态分配的资源，防止内存泄漏。例如，`BattleState`在`onExit`中删除了动态创建的`backToTestButton_`。
3.  **`handleEvent(App& app, const SDL_Event& e)`**: 处理SDL事件（如鼠标点击、键盘输入）。这是用户与游戏交互的主要入口。每个状态可以根据自身逻辑决定如何响应事件。例如，`MainMenuState`在此函数中检测按钮点击并触发状态切换。
4.  **`update(App& app, float deltaSeconds)`**: 在每一帧主循环中被调用，用于更新游戏逻辑。`deltaSeconds`参数提供了自上一帧以来经过的时间，使得游戏逻辑与帧率无关（时间步进）。例如，`MainMenuState`用它来更新数据流的下落位置和星光的闪烁。
5.  **`render(App& app)`**: 在每一帧主循环中被调用，负责将当前状态的视觉内容绘制到屏幕上。它通过`App`获取`SDL_Renderer`并执行绘制命令。

这些接口通过`virtual`关键字声明，确保了多态性。当`App`调用`state_->update(*this, dt)`时，实际执行的是当前`state_`所指向的具体子类（如`BattleState`）的`update`方法。

### 具体状态类实现

项目中的`states`目录包含了多个继承自`State`的具体状态类，如`MainMenuState`、`BattleState`等。每个类都重写了上述五个虚函数，以实现其独特的行为。

例如，`MainMenuState`的`render`函数不仅绘制了按钮和标题，还实现了复杂的视觉效果，包括：
-   **科技感数据流**：一组从上至下滚动的乱码字符，模拟数字世界的视觉风格。
-   **闪烁星光**：随机分布在屏幕上的光点，亮度周期性变化。
-   **标题光晕**：通过多层带有偏移和缩放的阴影纹理，为标题文字“溯洄遗梦”创建了绚丽的发光效果。

这些效果的实现细节（如字符生成、位置计算、颜色混合）都被封装在`MainMenuState`内部，与`App`和其他状态完全解耦。

**本节来源**
- [State.h](file://Tracer/src/core/State.h#L1-L17)
- [MainMenuState.cpp](file://Tracer/src/states/MainMenuState.cpp#L1-L401)
- [BattleState.cpp](file://Tracer/src/states/BattleState.cpp#L1-L799)

## App类与状态机控制

`App`类是整个游戏的控制中心，扮演着状态机的“上下文”（Context）角色。

### 唯一指针与内存安全

`App`通过`std::unique_ptr<State> state_;`来管理当前状态对象。`std::unique_ptr`是一种智能指针，它保证了对所指对象的独占所有权，并在指针被销毁或重置时自动调用`delete`，从而防止内存泄漏。

`setState`方法是状态切换的核心：

```cpp
void App::setState(std::unique_ptr<State> nextState) {
    if (state_) state_->onExit(*this);
    state_ = std::move(nextState);
    if (state_) state_->onEnter(*this);
}
```

该方法的执行流程如下：
1.  **清理旧状态**：如果当前存在一个状态（`state_`不为空），则调用其`onExit`方法，让旧状态有机会进行清理。
2.  **转移所有权**：使用`std::move`将`nextState`的所有权转移给`state_`。`std::move`将`nextState`转换为右值引用，使得`state_`可以“窃取”其内部的原始指针，而`nextState`本身变为空。这个过程是高效的，没有对象的拷贝开销。
3.  **初始化新状态**：如果新的状态对象不为空，则调用其`onEnter`方法，让新状态进行初始化。

这种设计确保了状态切换过程的原子性和安全性：旧状态被完全清理后，新状态才被激活，且内存的分配与释放完全由智能指针自动化管理。

### 单例模式的体现

虽然`App`类没有显式地实现单例模式（如私有化构造函数和提供`getInstance`静态方法），但在`main.cpp`中，它实际上是以单例的形式被使用的：

```cpp
int main(int, char**) {
    App app; // 全局唯一的App实例
    if (!app.init("溯洄遗梦 - 主菜单", 1280, 720)) return 1;
    app.setState(std::make_unique<MainMenuState>());
    app.run();
    return 0;
}
```

整个程序的生命周期内，只有一个`App`对象被创建。这个实例通过引用（`App& app`）被传递给每一个`State`对象，使得所有状态都能访问到共享的`SDL_Window`、`SDL_Renderer`和游戏全局数据。这符合单例模式“确保一个类只有一个实例，并提供一个全局访问点”的核心思想。

**本节来源**
- [App.h](file://Tracer/src/core/App.h#L1-L30)
- [App.cpp](file://Tracer/src/core/App.cpp#L1-L77)
- [main.cpp](file://Tracer/src/main.cpp#L1-L13)

## 主循环与时间步进机制

`App::run()`方法实现了游戏的主循环，这是游戏运行的“心脏”。

```cpp
void App::run() {
    Uint64 prev = SDL_GetPerformanceCounter();
    while (running_) {
        // 事件处理
        while (SDL_PollEvent(&e)) {
            if (e.type == SDL_QUIT) { running_ = false; }
            if (state_) state_->handleEvent(*this, e);
        }

        // 计算时间步长
        Uint64 now = SDL_GetPerformanceCounter();
        double delta = (double)(now - prev) / (double)SDL_GetPerformanceFrequency();
        prev = now;

        // 更新逻辑
        if (state_) state_->update(*this, static_cast<float>(delta));

        // 渲染
        SDL_SetRenderDrawColor(renderer_, 10, 10, 12, 255);
        SDL_RenderClear(renderer_);
        if (state_) state_->render(*this);
        SDL_RenderPresent(renderer_);
    }
}
```

### deltaTime的计算

`deltaTime`（在代码中为`delta`）的计算是实现流畅、稳定游戏体验的关键。它使用了SDL的高性能计数器：

1.  `SDL_GetPerformanceCounter()`返回一个高精度的计数器值。
2.  `SDL_GetPerformanceFrequency()`返回计数器每秒的滴答数。
3.  `delta`的计算公式为：`(now - prev) / frequency`，结果是一个以秒为单位的浮点数，表示自上一帧以来经过的时间。

例如，如果上一帧在1.0秒时计数为1000，当前帧在1.016秒时计数为1016，且频率为1000 Hz，则`delta = (1016 - 1000) / 1000 = 0.016`秒（16毫秒）。

### 在平滑动画中的作用

`deltaTime`使得游戏逻辑的更新与硬件的渲染速度解耦。假设一个动画要求每秒移动100像素：

-   **无`deltaTime`**：如果直接在`update`中移动固定像素（如`position += 2;`），那么在60 FPS的机器上，每秒移动`2 * 60 = 120`像素；在30 FPS的机器上，每秒移动`2 * 30 = 60`像素。速度不一致。
-   **有`deltaTime`**：正确的做法是`position += 100 * delta;`。无论帧率如何，`delta`会自动调整增量。在60 FPS时，`delta ≈ 0.0167`，移动`100 * 0.0167 ≈ 1.67`像素/帧；在30 FPS时，`delta ≈ 0.0333`，移动`100 * 0.0333 ≈ 3.33`像素/帧。最终，两者每秒都移动了100像素。

在`MainMenuState`中，数据流的下落速度`speed`（单位：像素/秒）与`delta`相乘，确保了无论帧率高低，数据流的下落速度都是恒定的，从而实现了平滑的动画效果。

**本节来源**
- [App.cpp](file://Tracer/src/core/App.cpp#L50-L77)
- [MainMenuState.cpp](file://Tracer/src/states/MainMenuState.cpp#L300-L320)

## 数据流与事件传递

游戏的数据流清晰地分为两个方向：事件流（输入）和渲染流（输出）。

### 事件流：SDL事件的分发

1.  **事件产生**：用户的输入（鼠标、键盘）由操作系统捕获，并由SDL库生成`SDL_Event`对象。
2.  **事件轮询**：`App::run()`中的`SDL_PollEvent`循环不断地从SDL事件队列中取出事件。
3.  **事件转发**：`App`不直接处理这些事件，而是将其转发给当前的`state_`对象，调用`state_->handleEvent(*this, e)`。
4.  **事件处理**：具体的状态类（如`MainMenuState`）根据事件类型（如`SDL_MOUSEBUTTONDOWN`）和事件数据（如鼠标坐标）来决定如何响应。例如，`MainMenuState`会检查鼠标点击是否落在某个按钮的矩形区域内，如果是，则执行相应的操作（如切换到`BattleState`）。

这种分发机制使得`App`保持了轻量级，它只负责事件的传递，而将具体的业务逻辑交由当前状态处理，符合单一职责原则。

### 渲染流：绘制命令的传递

1.  **渲染请求**：`App::run()`在每一帧调用`state_->render(*this)`。
2.  **渲染执行**：具体的状态类（如`BattleState`）开始其渲染逻辑。它通过`app.getRenderer()`获取`SDL_Renderer`的指针。
3.  **命令链式调用**：状态类调用SDL的渲染API（如`SDL_SetRenderDrawColor`, `SDL_RenderFillRect`, `SDL_RenderCopy`）来绘制背景、UI元素和游戏对象。
4.  **UI组件渲染**：对于复杂的UI元素（如`Button`），状态类会调用其`render(renderer)`方法。`Button`类内部再使用`SDL_Renderer`来绘制按钮的矩形和文本。
5.  **画面呈现**：`App`在所有渲染命令执行完毕后，调用`SDL_RenderPresent(renderer_)`，将渲染缓冲区的内容提交给GPU，最终显示在屏幕上。

整个渲染流程是一个自上而下的命令传递过程，从`App`到`State`，再到具体的`Button`等UI组件，最终到达`SDL_Renderer`。

**本节来源**
- [App.cpp](file://Tracer/src/core/App.cpp#L50-L77)
- [MainMenuState.cpp](file://Tracer/src/states/MainMenuState.cpp#L350-L401)
- [BattleState.cpp](file://Tracer/src/states/BattleState.cpp#L500-L799)

## 渲染流程与UI结构

游戏的UI结构在不同状态下呈现出不同的主题和布局。

### 主菜单状态 (MainMenuState)

`MainMenuState`采用了“科技感”与“传统美学”融合的视觉风格。
-   **背景**：深色背景（`#080a10`）营造出神秘感。
-   **核心元素**：居中的大标题“溯洄遗梦”是视觉焦点，通过多层光晕和偏移的阴影纹理实现了强烈的发光效果。
-   **动态效果**：
    -   **数据流**：屏幕两侧的垂直乱码字符流，模拟数字世界的视觉语言。
    -   **星光**：随机分布的闪烁光点，增加画面的生动感。
    -   **装饰花纹**：角落和按钮周围的点状装饰，强化科技感。
-   **交互元素**：底部的按钮组，采用简洁的矩形设计，带有侧边装饰线和角落光点。

### 战斗状态 (BattleState)

`BattleState`则完全转向了“水墨风格”的东方美学。
-   **背景**：宣纸色背景（`#f5f0e6`）奠定了水墨画的基调。
-   **核心元素**：
    -   **八卦阴阳鱼**：位于左侧的大型八卦图，其黑白比例会根据`yinYangBalance_`动态变化，是战斗系统的核心视觉符号。
    -   **铃铛**：位于右上角的传统铃铛，增加了文化氛围。
-   **游戏区域**：
    -   **卡牌槽**：3x4网格布局，前两行较小，第三行稍大并有分界线，用于放置卡牌。
    -   **手牌区**：位于底部中央，根据手牌数量动态调整位置。
    -   **牌堆**：位于右下角的抽牌堆和弃牌堆。
-   **装饰风格**：大量使用了预计算的墨点、晕染效果、书法线条和云纹，这些装饰并非每帧重新生成，而是预先计算好坐标，每帧直接绘制，避免了性能开销和视觉闪烁。

**本节来源**
- [MainMenuState.cpp](file://Tracer/src/states/MainMenuState.cpp#L200-L401)
- [BattleState.cpp](file://Tracer/src/states/BattleState.cpp#L100-L799)

## 单例模式的应用与评估

如前所述，`App`类在实践中扮演了单例的角色。

### 应用合理性

1.  **全局访问性**：游戏的许多系统（如渲染、音频、输入）都需要一个全局的访问点。`App`作为单例，为所有`State`和`Button`等UI组件提供了便捷的途径来访问`SDL_Renderer`和`SDL_Window`，避免了在函数间层层传递这些对象。
2.  **生命周期管理**：`App`的生命周期与整个游戏程序一致，从`main`函数开始，到`main`函数结束。将其设计为单例（或在此处作为唯一实例）是自然且合理的。
3.  **简化设计**：对于像游戏主控这样的核心类，通常只需要一个实例。强制单例可以防止意外创建多个实例，简化了设计和调试。

### 潜在局限性

1.  **测试困难**：单例模式引入了全局状态，使得单元测试变得困难。测试一个依赖`App`单例的`State`类时，很难模拟或隔离`App`的行为。
2.  **紧耦合**：`State`类直接依赖于`App`单例，这增加了它们之间的耦合度。如果未来需要改变`App`的接口，所有`State`类都可能需要修改。
3.  **隐藏依赖**：`State`类的构造函数不显式声明对`App`的依赖，而是通过成员函数调用。这使得类的依赖关系不够清晰，降低了代码的可读性和可维护性。

尽管存在这些局限性，但在本项目的规模和上下文中，`App`作为事实上的单例是一种实用且高效的选择。其带来的便利性远大于其潜在的缺点。

**本节来源**
- [App.h](file://Tracer/src/core/App.h#L1-L30)
- [MainMenuState.h](file://Tracer/src/states/MainMenuState.h#L1-L69)
- [BattleState.h](file://Tracer/src/states/BattleState.h#L1-L81)

## 架构权衡与改进空间

### 为何选择状态模式

项目选择状态模式而非MVC或ECS，是基于其特定需求的合理决策：

-   **与MVC的对比**：MVC（模型-视图-控制器）适用于数据驱动的应用，强调数据、视图和控制逻辑的分离。而《溯洄遗梦》的核心是**不同的游戏场景**（主菜单、战斗、卡牌管理），每个场景有完全独立的UI和交互逻辑。状态模式能更自然地将这些场景划分为独立的、互斥的模块，每个模块（状态）自包含其视图和控制器逻辑，比MVC的跨模块协调更简洁。
-   **与ECS的对比**：ECS（实体-组件-系统）适用于需要高度动态组合和大量同类型实体的游戏（如RPG、RTS）。《溯洄遗梦》目前的状态是宏观的、互斥的，而非由成百上千个微小实体构成。为每个状态引入ECS的复杂性是过度设计。状态模式提供了更直接、更易于理解的高层架构。

因此，状态模式完美契合了“游戏由一系列互斥的、自包含的场景组成”这一需求。

### 改进空间：状态间通信

当前架构的一个主要改进空间在于**状态间的通信机制**。

目前，状态切换是通过`App::setState`直接完成的，且`State`基类的接口中没有提供标准的通信方法。例如，从`BattleState`切换回`MainMenuState`时，如何将战斗结果（如得分、获得的卡牌）传递给主菜单？当前的实现（如`pendingGoTest_`标志）是临时的、非标准化的。

**改进建议**：
1.  **引入全局游戏状态管理器**：创建一个`GameStateManager`或`GameContext`单例，用于存储所有状态共享的数据（如玩家信息、库存、进度）。所有`State`都可以读写这个全局上下文。
2.  **在`setState`中传递数据**：修改`setState`方法，允许传递一个`void*`或`std::any`类型的参数，或者创建一个`StateTransitionData`结构体，用于携带切换时需要传递的信息。
3.  **使用观察者模式**：让`App`或`GameStateManager`作为事件发布者，状态作为订阅者。当一个状态需要通知另一个状态时，可以发布一个事件。

采用第一种方案（全局管理器）是最简单且最符合当前架构的改进方式。

**本节来源**
- [App.cpp](file://Tracer/src/core/App.cpp#L70-L77)
- [BattleState.cpp](file://Tracer/src/states/BattleState.cpp#L450-L460)

## 结论

《溯洄遗梦》的架构设计以状态模式为核心，通过`App`类对`std::unique_ptr<State>`的管理，实现了安全、清晰的状态切换和内存自动管理。`State`基类定义的五大人机交互接口为所有具体状态提供了统一的契约。主循环中的`deltaTime`机制确保了游戏逻辑的帧率无关性，实现了平滑的动画效果。数据流清晰地分为事件分发和渲染命令传递两条路径。`App`类作为事实上的单例，为整个系统提供了全局访问点，虽然存在耦合度高的局限性，但在本项目中是合理的选择。整体架构简洁高效，非常适合管理游戏的不同宏观场景。未来的改进应着重于建立标准化的状态间通信机制，以支持更复杂的游戏逻辑和数据传递。